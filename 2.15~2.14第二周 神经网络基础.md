# 2.15~2.14第二周 神经网络基础
[TOC]

### 2.15 Python 中的广播机制（Broadcasting in Python）
![ea243103.png](:storage\964c5925-1e39-4450-8124-7afe77a826b0\ea243103.png)
&emsp; 用矩阵运算的方式计算不同食物中不同营养成分中的卡路里百分比。
* 求和矩阵cal=目标矩阵A.sum(axis=0)
	&emsp; 上式表示对矩阵A按列求和，axis 用来指明将要进行的运算是沿着哪个轴执行，在numpy中，0轴是垂直的，也就是列，而1 轴是水平的，也就是行。

* 和矩阵cal.reshape(1,4)
&emsp; 将矩阵cal重塑成1\*4矩阵，当我们写代码时不确定矩阵维度的时候，通常会对矩阵
进行重塑来确保得到我们想要的是列向量或行向量。
&emsp; 另外，重塑操作reshape是一个常量时间的操作，时间复杂度是O(1)，它的调用代价极低。

* numpy的广播机制
	* &emsp; 当一个1\*4的列向量与一个常数做加法时，实际上会将常数扩展为一个1\*4的列向量，然后两者做逐元素加法。 **注意：** 这种广播机制只对单行向量和单列向量可以使用。
	* &emsp; 泛化形式是n\*m的矩阵和n\*1或1\*m的矩阵相加。在执行加法操作时，其实是将n\*1或1\*m矩阵复制成为n\*m的矩阵，然后两者做逐元素加法得到结果。
<br>

* 广播机制的通用形式
	* &emsp;  一个m\*n矩阵 加/减/乘/除 一个 n\*1或1\*m的单行或列矩阵，这个行或列矩阵n\*1或1\*m矩阵都会复制自身成为m\*n矩阵，然后才与那个m\*n矩阵逐元素 加/减/乘/除
	* &emsp;  此通用形式不仅对单行或列矩阵有效，对实数也有同样效果，实数与m\*n矩阵四则运算前也会自身先扩展成一个m\*n矩阵再与这个矩阵逐元素运算。
	* &emsp;  单行或列矩阵与实数四则运算，实数也执行广播机制再逐元素运算




<!--stackedit_data:
eyJoaXN0b3J5IjpbNDAxMzE3MzQ5XX0=
-->